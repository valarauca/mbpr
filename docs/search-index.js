var searchIndex = {};
searchIndex["mbpr"] = {"doc":"Nom based decoder for Memcached Binary Packet Protol","items":[[3,"Request","mbpr","Memcached Request Packet",null,null],[3,"OwnedRequest","","Clones Buffers",null,null],[12,"key","","",0,null],[12,"extra","","",0,null],[12,"body","","",0,null],[3,"ReqHeader","","Memcached Request Packet Header",null,null],[3,"Response","","Memcached Response Packet",null,null],[3,"OwnedResponse","","Clones Buffers",null,null],[12,"extra","","",1,null],[12,"key","","",1,null],[12,"body","","",1,null],[3,"ResHeader","","Memcached Response Packet Header",null,null],[3,"Encoder","","Data type used to encode data efficient",null,null],[4,"OpCode","","Memcache Opcodes",null,null],[13,"Get","","",2,null],[13,"Set","","",2,null],[13,"Add","","",2,null],[13,"Replace","","",2,null],[13,"Delete","","",2,null],[13,"Increment","","",2,null],[13,"Decrement","","",2,null],[13,"Quit","","",2,null],[13,"Flush","","",2,null],[13,"GetQ","","",2,null],[13,"Nop","","",2,null],[13,"Version","","",2,null],[13,"GetK","","",2,null],[13,"GetKQ","","",2,null],[13,"Append","","",2,null],[13,"Prepare","","",2,null],[13,"Stat","","",2,null],[13,"SetQ","","",2,null],[13,"AddQ","","",2,null],[13,"ReplaceQ","","",2,null],[13,"DeleteQ","","",2,null],[13,"IncrementQ","","",2,null],[13,"DecrementQ","","",2,null],[13,"QuitQ","","",2,null],[13,"FlushQ","","",2,null],[13,"AppendQ","","",2,null],[13,"PrependQ","","",2,null],[13,"Verbosity","","",2,null],[13,"Touch","","",2,null],[13,"GAT","","",2,null],[13,"GATQ","","",2,null],[13,"SASLlistmech","","",2,null],[13,"SASLAuth","","",2,null],[13,"SASLStep","","",2,null],[13,"RGet","","",2,null],[13,"RSet","","",2,null],[13,"RSetQ","","",2,null],[13,"RAppend","","",2,null],[13,"RAppendQ","","",2,null],[13,"RPrepend","","",2,null],[13,"RPrependQ","","",2,null],[13,"RDelete","","",2,null],[13,"RDeleteQ","","",2,null],[13,"RIncr","","",2,null],[13,"RIncrQ","","",2,null],[13,"RDecr","","",2,null],[13,"RDecrQ","","",2,null],[13,"SetVBucket","","",2,null],[13,"GetVBucket","","",2,null],[13,"DelVBucket","","",2,null],[13,"TAPConnect","","",2,null],[13,"TAPMutate","","",2,null],[13,"TAPDelete","","",2,null],[13,"TAPFlush","","",2,null],[13,"TAPOpaque","","",2,null],[13,"TAPVBucketSet","","",2,null],[13,"TAPCheckpointStart","","",2,null],[13,"TAPCheckpointEnd","","",2,null],[4,"StatusField","","Status Field",null,null],[13,"NoError","","",3,null],[13,"KeyNotFound","","",3,null],[13,"KeyExists","","",3,null],[13,"ValueTooLarge","","",3,null],[13,"InvalidArguments","","",3,null],[13,"ItemNotStored","","",3,null],[13,"IncrDecrNonNumeric","","",3,null],[13,"VBucketNotHere","","",3,null],[13,"AuthError","","",3,null],[13,"AuthContinue","","",3,null],[13,"UnknownCommand","","",3,null],[13,"OutOfMemory","","",3,null],[13,"NotSupported","","",3,null],[13,"InternalError","","",3,null],[13,"Busy","","",3,null],[13,"TemporaryFailure","","",3,null],[4,"Fault","","Parsing Error structure",null,null],[13,"BadOpCode","","Opcode does not conform to the standard",4,null],[13,"BadStatus","","Status code does not conform to standard",4,null],[13,"Incomplete","","More data is needed to fully parse packet.",4,null],[13,"BadMagic","","Fixed initial field",4,null],[13,"InvalidPacket","","",4,null],[4,"ParseResult","","Internal Result type",null,null],[13,"Ok","","",5,null],[13,"Err","","",5,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"eq","","",2,null],[11,"into","","Converts an OpCode into it&#39;s byte code (at no\ncomputation cost) for encoding",2,null],[11,"encode","","Writes opcode into `buffer[1]`",2,null],[11,"clone","","",3,null],[11,"fmt","","",3,null],[11,"eq","","",3,null],[11,"check_status","","Base implementatin of status method",3,null],[11,"into","","",3,null],[11,"encode","","Encodes value into packet",3,null],[11,"clone","","",6,null],[11,"fmt","","",6,null],[11,"eq","","",6,null],[11,"ne","","",6,null],[11,"parse","","Parse a request header",6,null],[11,"get_opaque","","",6,null],[11,"get_cas","","",6,null],[11,"get_opcode","","",6,null],[11,"get_vbucket_id","","",6,null],[11,"get_keylen","","",6,null],[11,"get_bodylen","","",6,null],[11,"get_extralen","","",6,null],[11,"encode","","Fast encoding method",6,null],[11,"clone","","",7,null],[11,"fmt","","",7,null],[11,"parse","","Parse and borrow a packet from a buffer",7,null],[11,"new","","This interface does ABSOLUTELY NO verfication of the packet\nit is expected if you are calling this method you understand\nthe memcached protocol and you are going to use this to generate\na valid packet.",7,{"inputs":[{"name":"opcode"},{"name":"u16"},{"name":"u32"},{"name":"u64"},{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"request"}}],[11,"rebuild","","Over write an existing request",7,null],[11,"encode_self","","Allocates a new buffer and encodes this packets contents into it.\nthis method works out to a handful of `memcp` primatives and is\nfairly quick as their is no bounds checking (buffer length is\nasserted on construction).",7,null],[11,"encode_into_buffer","","If you are using a slab to avoid making too many allocations\nthis method will check check the `Vec&lt;u8&gt;` it is passed\nonly reserving additional capacity if necessary. If the `Vec&lt;u8&gt;`\nhas enough capacity no action is taken.",7,null],[11,"get_opcode","","",7,null],[11,"get_opaque","","",7,null],[11,"get_cas","","",7,null],[11,"get_vbucket_id","","",7,null],[11,"has_extra","","",7,null],[11,"has_key","","",7,null],[11,"get_extra","","",7,null],[11,"get_key","","",7,null],[11,"get_key_str","","The standard states the key should be an ASCII compatible string\nso this method preforms that conversion without checking for\ncorrectness.",7,null],[11,"has_body","","",7,null],[11,"get_body","","",7,null],[11,"to_owned","","Consume this item and take ownership",7,null],[11,"get_keylen","","Get size of Packet&#39;s Key Field",7,null],[11,"get_bodylen","","Get size of Packet&#39;s Body Field (Raw Data)",7,null],[11,"get_extralen","","Get size of Packet&#39;s Extra Field (Flags, Arguments, Etc. command specific)",7,null],[11,"encode","","Encode a packet",7,null],[11,"clone","","",0,null],[11,"parse","","Reads a full packet and COPIES it&#39;s buffers into its own.\nAllocation is lazy. Fields that are not used are not allocated.\nFields are not allocated WHILE parsing, only when complete.",0,null],[11,"new","","This interface does ABSOLUTELY NO verfication of the packet\nit is expected if you are calling this method you understand\nthe memcached protocol and you are going to use this to generate\na valid packet.",0,{"inputs":[{"name":"opcode"},{"name":"u16"},{"name":"u32"},{"name":"u64"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":{"name":"self"}}],[11,"rebuild","","Over write an existing request",0,null],[11,"encode_self","","Allocates a new buffer and encodes this packets contents into it.\nthis method works out to a handful of `memcp` primatives and is\nfairly quick as their is no bounds checking (buffer length is\nasserted on construction).",0,null],[11,"encode_into_buffer","","If you are using a slab to avoid making too many allocations\nthis method will check check the `Vec&lt;u8&gt;` it is passed\nonly reserving additional capacity if necessary. If the `Vec&lt;u8&gt;`\nhas enough capacity no action is taken.",0,null],[11,"get_opcode","","",0,null],[11,"get_opaque","","",0,null],[11,"get_cas","","",0,null],[11,"get_vbucket_id","","",0,null],[11,"has_extra","","",0,null],[11,"get_extra","","",0,null],[11,"has_key","","",0,null],[11,"get_key","","",0,null],[11,"get_key_str","","The standard states the key should be an ASCII compatible string\nso this method preforms that conversion without checking for\ncorrectness.",0,null],[11,"has_body","","",0,null],[11,"get_body","","",0,null],[11,"get_keylen","","Get size of Packet&#39;s Key Field",0,null],[11,"get_bodylen","","Get size of Packet&#39;s Body Field (Raw Data)",0,null],[11,"get_extralen","","Get size of Packet&#39;s Extra Field (Flags, Arguments, Etc. command specific)",0,null],[11,"encode","","Encode a packet",0,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"get_opcode","","",8,null],[11,"get_opaque","","",8,null],[11,"get_cas","","",8,null],[11,"check_status","","Check Status Field",8,null],[11,"parse","","Parse a packet header",8,null],[11,"get_keylen","","",8,null],[11,"get_extralen","","",8,null],[11,"get_bodylen","","",8,null],[11,"encode","","Relatively fast method for encoding header",8,null],[11,"clone","","",9,null],[11,"fmt","","",9,null],[11,"parse","","Parse a full response. Internal Key/Extra/Body fields are borrowed.",9,null],[11,"encode_self","","Allocates a new buffer and encodes this packets contents into it.\nthis method works out to a handful of `memcp` primatives and is\nfairly quick as their is no bounds checking (buffer length is\nasserted on construction).",9,null],[11,"encode_into_buffer","","If you are using a slab to avoid making too many allocations\nthis method will check check the `Vec&lt;u8&gt;` it is passed\nonly reserving additional capacity if necessary. If the `Vec&lt;u8&gt;`\nhas enough capacity no action is taken.",9,null],[11,"new","","This interface does ABSOLUTELY NO verfication of the packet\nit is expected if you are calling this method you understand\nthe memcached protocol and you are going to use this to generate\na valid packet.",9,{"inputs":[{"name":"opcode"},{"name":"statusfield"},{"name":"u32"},{"name":"u64"},{"name":"option"},{"name":"option"},{"name":"option"}],"output":{"name":"response"}}],[11,"rebuild","","Over write an existing request",9,null],[11,"get_opcode","","",9,null],[11,"get_opaque","","",9,null],[11,"get_cas","","",9,null],[11,"check_status","","Check Status Field",9,null],[11,"has_extra","","",9,null],[11,"get_extra","","",9,null],[11,"has_key","","",9,null],[11,"get_key","","",9,null],[11,"get_key_str","","The standard states the key should be an ASCII compatible string\nso this method preforms that conversion without checking for\ncorrectness.",9,null],[11,"has_body","","",9,null],[11,"get_body","","",9,null],[11,"to_owned","","Consume this item and take ownership",9,null],[11,"get_keylen","","Get size of Packet&#39;s Key Field",9,null],[11,"get_bodylen","","Get size of Packet&#39;s Body Field (Raw Data)",9,null],[11,"get_extralen","","Get size of Packet&#39;s Extra Field (Flags, Arguments, Etc. command specific)",9,null],[11,"encode","","Relatively fast method for encoding header",9,null],[11,"encode","","Relatively fast method for encoding header",1,null],[11,"get_keylen","","Get size of Packet&#39;s Key Field",1,null],[11,"get_bodylen","","Get size of Packet&#39;s Body Field (Raw Data)",1,null],[11,"get_extralen","","Get size of Packet&#39;s Extra Field (Flags, Arguments, Etc. command specific)",1,null],[11,"parse","","Reads a full packet and COPIES it&#39;s buffers into its own.\nAllocation is lazy. Fields that are not used are not allocated.\nFields are not allocated WHILE parsing, only when complete.",1,null],[11,"encode_self","","Allocates a new buffer and encodes this packets contents into it.\nthis method works out to a handful of `memcp` primatives and is\nfairly quick as their is no bounds checking (buffer length is\nasserted on construction).",1,null],[11,"encode_into_buffer","","If you are using a slab to avoid making too many allocations\nthis method will check check the `Vec&lt;u8&gt;` it is passed\nonly reserving additional capacity if necessary. If the `Vec&lt;u8&gt;`\nhas enough capacity no action is taken.",1,null],[11,"new","","",1,{"inputs":[{"name":"opcode"},{"name":"statusfield"},{"name":"u32"},{"name":"u64"},{"name":"vec"},{"name":"vec"},{"name":"vec"}],"output":{"name":"self"}}],[11,"rebuild","","Over write an existing request",1,null],[11,"get_opcode","","",1,null],[11,"get_opaque","","",1,null],[11,"get_cas","","",1,null],[11,"check_status","","If the condition `StatusField::NoError` is set this\nwill return `Ok(())`, if there is an error it will\nreturn it in `Err(StatusField::_)`",1,null],[11,"has_extra","","",1,null],[11,"get_extra","","",1,null],[11,"has_key","","",1,null],[11,"get_key","","",1,null],[11,"get_key_str","","The standard states the key should be an ASCII compatible string\nso this method preforms that conversion without checking for\ncorrectness.",1,null],[11,"has_body","","",1,null],[11,"get_body","","",1,null],[8,"Encoding","","Trait for encoding the value into a packet",null,null],[10,"encode","","Simple method to write the internal data into a buffer",10,null],[8,"PacketVal","","Values encoded within Memcached packets",null,null],[10,"get_keylen","","",11,null],[10,"get_extralen","","",11,null],[10,"get_bodylen","","",11,null],[11,"total_len","","The total length of the packet",11,null],[11,"clone","","",4,null],[11,"fmt","","",4,null],[11,"eq","","",4,null],[11,"unwrap","","Unwraps the value. Panics on failure",5,null],[11,"is_ok","","Checks if value is okay",5,null],[11,"is_err","","Check if the value is error",5,null],[11,"ok","","Get Okay Value",5,null],[11,"err","","Get Error Value",5,null],[11,"from","","You can ignore this",5,{"inputs":[{"name":"iresult"}],"output":{"name":"parseresult"}}],[11,"new","","Pass an already constructed packet in. This will allocate a buffer\nthe size of that packet",12,{"inputs":[{"name":"p"}],"output":{"name":"encoder"}}],[11,"from_vec","","To avoid allocations this method allows for a pre-allocated vector\nbe passed in. The Vector&#39;s size will be checked, and it **MAY** be resized\nif too small. If it&#39;s capacity is sufficient no allocations will be done.",12,{"inputs":[{"name":"p"},{"name":"vec"}],"output":{"name":"encoder"}}],[11,"get_vec","","Consumes this type (destroying it) but returns the underlying vector\nas to not dellocator it&#39;s memory (be used again).",12,null],[11,"with_capacity","","Used internally for testing, maybe useful to the developer reading this\nthis allows for the input value to set the len/capacity of the internal\nmemory",12,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"as_slice","","While the underlying `vec` is fully populated this returns\nonly the data written to it. So if `with::capacity` is used\nto create a buffer _larger_ then a packet this can be used\nto read only the packet data.",12,null],[11,"len","","Get length of data written to the encoder",12,null],[11,"encode_u8","","Encode a u8 used internally.",12,null],[11,"encode_u16","","Encode a u16 used internally.",12,null],[11,"encode_u32","","Encode a u32 used internally.",12,null],[11,"encode_u64","","Encode a u64 used internally.",12,null],[11,"encode_slice","","Encode a [u8] used internally.",12,null]],"paths":[[3,"OwnedRequest"],[3,"OwnedResponse"],[4,"OpCode"],[4,"StatusField"],[4,"Fault"],[4,"ParseResult"],[3,"ReqHeader"],[3,"Request"],[3,"ResHeader"],[3,"Response"],[8,"Encoding"],[8,"PacketVal"],[3,"Encoder"]]};
initSearch(searchIndex);
